<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Map with Data Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/datamaps/0.5.9/datamaps.all.min.js"></script>
    <style>
      html {
        height: 100%;
        width: 100%;
      }
      body {
        flex: '1 1 auto';
        align-self: 'stretch';
        margin: 0px;
        width: 100%;
        height: 100%;
        position: absolute;
        overflow: scroll;
      }
      #container {
          position: relative;
          margin: 0 auto;
          overflow: hidden;
          z-index: 1000;
          width: 80%;
      }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="table"></div>
    <script>
      const calculateTintAndShade = (
            hexColor, // using #663399 as an example
            percentage = 0.1 // using 10% as an example
      ) => {
        const r = parseInt(hexColor.slice(1, 3), 16); // r = 102
        const g = parseInt(hexColor.slice(3, 5), 16); // g = 51
        const b = parseInt(hexColor.slice(5, 7), 16); // b = 153

        /* 
          From this part, we are using our two formulas
          in this case, here is the formula for tint,
          please be aware that we are performing two validations
          we are using Math.min to set the max level of tint to 255,
          so we don't get values like 280 ;)
          also, we have the Math.round so we don't have values like 243.2
          both validations apply for both tint and shade as you can see */
        const tintR = Math.round(Math.min(255, r + (255 - r) * percentage)); // 117
        const tintG = Math.round(Math.min(255, g + (255 - g) * percentage)); // 71
        const tintB = Math.round(Math.min(255, b + (255 - b) * percentage)); // 163

      
        const shadeR = Math.round(Math.max(0, r - r * percentage)); // 92
        const shadeG = Math.round(Math.max(0, g - g * percentage)); // 46
        const shadeB = Math.round(Math.max(0, b - b * percentage)); // 138


        /* 
          Now with all the values calculated, the only missing stuff is 
          getting our color back to hexadecimal, to achieve that, we are going
          to perform a toString(16) on each value, so we get the hex value
          for each color, and then we just append each value together and voilÃ !*/
        return {
            tint: {
                r: tintR,
                g: tintG,
                b: tintB,
                hex:
                    '#' +
                    [tintR, tintG, tintB]
                        .map(x => x.toString(16).padStart(2, '0'))
                        .join(''), // #7547a3 
            },
            shade: {
                r: shadeR,
                g: shadeG,
                b: shadeB,
                hex:
                    '#' +
                    [shadeR, shadeG, shadeB]
                        .map(x => x.toString(16).padStart(2, '0'))
                        .join(''), // #5c2e8a 
            },
        };
    };


      // Parse URL search parameters
      const urlParams = new URLSearchParams(window.location.search);
      const paramsObject = Object.fromEntries(urlParams.entries());
      const mid = paramsObject.mid || 0 
      const label = paramsObject.label || 'value'
      const values = JSON.parse(paramsObject.value || [])
      const countryGroups = paramsObject.countries.split('|').map(t => t.split(','))
      const max = Math.max(...values)
      const min = Math.min(...values);
      function getColor(value, max, min, mid=0) {
          // If no value, return grey
          if (value === undefined) {
              return '#CCCCCC';
          }
          
          // Convert -1 to 1 scale to 0 to 1 scale
          value = (value - mid)/(max - min)
          var scale = (value + 1) / 2;
          
          // Calculate RGB values
          var r = Math.round(255 * (1 - scale));
          // var r = 0
          var g = Math.round(255 * scale);
          var b = 0
          
          // Convert to hex
          var rHex = r.toString(16).padStart(2, '0');
          var gHex = g.toString(16).padStart(2, '0');
          var bHex = b.toString(16).padStart(2, '0');
          
          return ('#' + rHex + gHex + bHex).toUpperCase();
      }

      const dataset = {};
      countryGroups.forEach((cs, i) => {
        cs.forEach(country => {
          dataset[country] = { value: values[i], fillKey: country }
        })
      })

      const baseColor = '#4F46E5'
      const calcColor = (value) => {
        return value >= mid ? calculateTintAndShade(baseColor, (value - mid)/(max-mid)).shade.hex
          : calculateTintAndShade(baseColor, (value - mid) / (min-mid)).tint.hex
      }
      // Sample data: countries with values between -1 and 1
      var datasetDefault = {
          'USA': {value: 0.8, fillKey: 'USA'},
          'CAN': {value: 0.6, fillKey: 'CAN'},
          'RUS': {value: -0.7, fillKey: 'RUS'},
          'CHN': {value: -0.3, fillKey: 'CHN'},
          'BRA': {value: 0.4, fillKey: 'BRA'},
          'IND': {value: 0.2, fillKey: 'IND'},
          'AUS': {value: 0.9, fillKey: 'AUS'},
          'FRA': {value: -0.5, fillKey: 'FRA'},
          'DEU': {value: 0.3, fillKey: 'DEU'},
          'GBR': {value: 0.5, fillKey: 'GBR'},
      };

      // Function to convert value to color
      

      // Create color object for each country
      var colors = {};
      Object.keys(dataset).forEach(function(key) {
        colors[key] = getColor(dataset[key].value, max, min, mid);
        // colors[key] = calcColor(dataset[key].value);
      });

      const fills = {
        ...colors,
          defaultFill: '#222',
      }
      console.log(dataset)

      // Create the map
      var map = new Datamap({
        scope: 'world',
        element: document.getElementById('map'),
        responsive: true,
        projection: 'equirectangular',
        fills: fills,
        data: dataset,
        geographyConfig: {
            highlightOnHover: true,
            borderColor: '#666',
            popupTemplate: function(geo, data) {
                // Show country name and value in tooltip
                var value = dataset[geo.id]?.value !== undefined ? dataset[geo.id].value.toFixed(2) : 'No data';
                return '<div class="hoverinfo">' +
                        '<strong>' + geo.properties.name + '</strong><br>' +
                        label + ': ' + value +
                        '</div>';
            }
        }
      });

      // Make the map responsive
      window.addEventListener('resize', function() {
            map.resize();
      });

      // Create bar chart
      const margin = {top: 20, right: 40, bottom: 30, left: 120};
      const containerWidth = document.getElementById('table').offsetWidth;
      const width = containerWidth - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;

      const svg = d3.select("#table")
        .append("svg")
        .attr("width", "100%")
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Add viewBox for responsiveness
      d3.select(svg.node().parentNode)
        .attr("viewBox", `0 0 ${containerWidth} ${height + margin.top + margin.bottom}`)
        .attr("preserveAspectRatio", "xMinYMin meet");

      // Convert dataset object to array for D3
      const data = Object.entries(dataset).map(([country, data]) => ({
        country,
        value: data.value
      }));

      // Create scales (swapped x and y)
      const y = d3.scale.ordinal()
        .rangeRoundBands([0, height], .1)
        .domain(data.map(d => d.country));

      const x = d3.scale.linear()
        .range([0, width])
        .domain([min, max]);

      // Calculate center position for x-axis
      const xCenter = x(0);

      // Create axes
      const xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");

      const yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

      // Add x-axis at the center
      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis);

      // Add center line
      svg.append("line")
        .attr("class", "center-line")
        .attr("x1", x(0))
        .attr("x2", x(0))
        .attr("y1", 0)
        .attr("y2", height)
        .style("stroke", "#000")
        .style("stroke-width", "1px");

      // Add y-axis
      svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .selectAll("text")
        .style("text-anchor", "end");

      // Add bars
      svg.selectAll(".bar")
        .data(data)
        .enter().append("rect")
        .attr("class", "bar")
        .attr("y", d => y(d.country))
        .attr("height", y.rangeBand())
        .attr("x", d => d.value < 0 ? x(d.value) : x(0))
        .attr("width", d => Math.abs(x(d.value) - x(0)))
        .style("fill", d => getColor(d.value, max, min, mid));

      // Update styles
      const style = document.createElement('style');
      style.textContent = `
        .axis path,
        .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }
        .center-line {
          stroke-dasharray: 4,4;
        }
        .bar {
          fill: steelblue;
        }
        .bar:hover {
          opacity: 0.8;
        }
      `;
      document.head.appendChild(style);

      window.addEventListener('resize', function() {
        const newWidth = document.getElementById('table').offsetWidth - margin.left - margin.right;
        x.range([0, newWidth]);
        svg.select(".x.axis").call(xAxis);
        svg.select(".center-line")
            .attr("x1", x(0))
            .attr("x2", x(0));
        svg.selectAll(".bar")
            .attr("x", d => d.value < 0 ? x(d.value) : x(0))
            .attr("width", d => Math.abs(x(d.value) - x(0)));
      });
    </script>
</body>
</html>