<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Map with Data Colors</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/datamaps/0.5.9/datamaps.all.min.js"></script>
    <style>
      html {
        height: 100%;
        width: 100%;
      }
      body {
        flex: '1 1 auto';
        align-self: 'stretch';
        margin: 0px;
        width: 100%;
        height: 100%;
        position: absolute;
        overflow: hidden;
      }
      #container {
          position: relative;
          margin: 0 auto;
          overflow: hidden;
          z-index: 1000;
          width: 80%;
      }
    </style>
</head>
<body>
    <div id="container"></div>
    <script>
      const calculateTintAndShade = (
            hexColor, // using #663399 as an example
            percentage = 0.1 // using 10% as an example
        ) => {
            const r = parseInt(hexColor.slice(1, 3), 16); // r = 102
            const g = parseInt(hexColor.slice(3, 5), 16); // g = 51
            const b = parseInt(hexColor.slice(5, 7), 16); // b = 153

            /* 
              From this part, we are using our two formulas
              in this case, here is the formula for tint,
              please be aware that we are performing two validations
              we are using Math.min to set the max level of tint to 255,
              so we don't get values like 280 ;)
              also, we have the Math.round so we don't have values like 243.2
              both validations apply for both tint and shade as you can see */
            const tintR = Math.round(Math.min(255, r + (255 - r) * percentage)); // 117
            const tintG = Math.round(Math.min(255, g + (255 - g) * percentage)); // 71
            const tintB = Math.round(Math.min(255, b + (255 - b) * percentage)); // 163

          
            const shadeR = Math.round(Math.max(0, r - r * percentage)); // 92
            const shadeG = Math.round(Math.max(0, g - g * percentage)); // 46
            const shadeB = Math.round(Math.max(0, b - b * percentage)); // 138


            /* 
              Now with all the values calculated, the only missing stuff is 
              getting our color back to hexadecimal, to achieve that, we are going
              to perform a toString(16) on each value, so we get the hex value
              for each color, and then we just append each value together and voilÃ !*/
            return {
                tint: {
                    r: tintR,
                    g: tintG,
                    b: tintB,
                    hex:
                        '#' +
                        [tintR, tintG, tintB]
                            .map(x => x.toString(16).padStart(2, '0'))
                            .join(''), // #7547a3 
                },
                shade: {
                    r: shadeR,
                    g: shadeG,
                    b: shadeB,
                    hex:
                        '#' +
                        [shadeR, shadeG, shadeB]
                            .map(x => x.toString(16).padStart(2, '0'))
                            .join(''), // #5c2e8a 
                },
            };
        };


        // Parse URL search parameters
        const urlParams = new URLSearchParams(window.location.search);
        const paramsObject = Object.fromEntries(urlParams.entries());
        const value = JSON.parse(paramsObject.value || [])
        const countryGroups = paramsObject.countries.split('|').map(t => t.split(','))
        
        const dataset = {};
        countryGroups.forEach((cs, i) => {
          cs.forEach(country => {
            dataset[country] = { value: value[i], fillKey: country }
          })
        })

        const baseColor = '#4F46E5'
        const calcColor = (value) => {
          return value >= 0 ? calculateTintAndShade(baseColor, value).shade.hex
            : calculateTintAndShade(baseColor, -value).tint.hex
        }
        // Sample data: countries with values between -1 and 1
        var datasetDefault = {
            'USA': {value: 0.8, fillKey: 'USA'},
            'CAN': {value: 0.6, fillKey: 'CAN'},
            'RUS': {value: -0.7, fillKey: 'RUS'},
            'CHN': {value: -0.3, fillKey: 'CHN'},
            'BRA': {value: 0.4, fillKey: 'BRA'},
            'IND': {value: 0.2, fillKey: 'IND'},
            'AUS': {value: 0.9, fillKey: 'AUS'},
            'FRA': {value: -0.5, fillKey: 'FRA'},
            'DEU': {value: 0.3, fillKey: 'DEU'},
            'GBR': {value: 0.5, fillKey: 'GBR'},
        };

        // Function to convert value to color
        function getColor(value) {
            // If no value, return grey
            if (value === undefined) {
                return '#CCCCCC';
            }
            
            // Convert -1 to 1 scale to 0 to 1 scale
            var scale = (value + 1) / 2;
            
            // Calculate RGB values
            // var r = Math.round(255 * (1 - scale));
            var r = 0
            var g = Math.round(255 * scale);
            var b = 0
            
            // Convert to hex
            var rHex = r.toString(16).padStart(2, '0');
            var gHex = g.toString(16).padStart(2, '0');
            var bHex = b.toString(16).padStart(2, '0');
            
            return ('#' + rHex + gHex + bHex).toUpperCase();
        }

        // Create color object for each country
        var colors = {};
        Object.keys(dataset).forEach(function(key) {
          // colors[key] = getColor(dataset[key].value);
          colors[key] = calcColor(dataset[key].value);
        });

        const fills = {
          ...colors,
            defaultFill: '#efefee',
        }
        console.log(dataset)

        // Create the map
        var map = new Datamap({
            scope: 'world',
            element: document.getElementById('container'),
            responsive: true,
            projection: 'equirectangular',
            fills: fills,
            data: dataset,
            geographyConfig: {
                highlightOnHover: true,
                borderColor: '#666',
                popupTemplate: function(geo, data) {
                    // Show country name and value in tooltip
                    var value = dataset[geo.id]?.value !== undefined ? dataset[geo.id].value.toFixed(2) : 'No data';
                    return '<div class="hoverinfo">' +
                           '<strong>' + geo.properties.name + '</strong><br>' +
                           'Value: ' + value +
                           '</div>';
                }
            }
        });

        // Make the map responsive
        window.addEventListener('resize', function() {
            map.resize();
        });
    </script>
</body>
</html>